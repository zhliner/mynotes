并发是高效程序的基本点。
以并发的基本立足点，去思考事物逻辑，编写Go程序。Golang提供了并发的基础元件：Channel，Goroutine。

1.
利用Channel，一个Go程其实就是一个“微服务器”。
向Go程传递一个关闭控制句柄，Go程返回一个读取Channel。可实现干净的并发Go程设计。
代码：
    // file1.go
    func canceller(stop <-chan struct{}) func() bool {
        return func() bool {
            select {
            case <-stop:
                return true
            default:
                return false
            }
        }
    }
    // 关闭信号，外部控制
    stop := make(chan struct{})
    // 关闭控制句柄
    cancel := canceller(stop)

    for v := <-Increaser(cancel) {
        fmt.Println(v)
        if v == 1000 {
            close(stop)  // 由外部控制微服务
        }
    }

    // file2.go
    // 微服务生成
    // 返回一个整数递增器。
    // - 外部通过close(stop)通知内部结束服务；
    // - 内部close(ch)结束服务，外部读取关闭信号确认结束；
    func Increaser(cancel func() bool) <-chan int {
        ch := make(chan int)
        go func() {
            var i int
            for {
                if cancel() {
                    break
                }
                ch <- i
                i++
            }
            close(ch)
        }
        return ch
    }

小结：
    接口是用户，Go程是服务。
    用微服务的想法思考需求，会自然地走入并发设计。

服务的逻辑：
    可独立的，不在“流程”之中的——可脱离当前执行流。



///////////////////////////////////////////////////////////////////////////////


结构体匿名嵌入未导出类型，但可导出其导出字段，
这是一种有意思的继承模式，可实现隐藏和公开的某种折衷平衡。
代码：
    type info struct {
        ID   string
        Name string
        Age  int
    }
    type Info struct {
        ID   []byte
        info
    }
    // ID 转换，其它成员继承
    // 隐藏 ID 差别
    func Load(dt info) Info {
        id := parse(dt.ID)
        return Info{id, info{dt}}
    }

后记：
此种设计方式不便于接口清晰。godoc不会显示未导出类型的可导出字段。
可能的情况下尽量重新考虑接口关系。



///////////////////////////////////////////////////////////////////////////////


并发设计约定
1.
包级函数默认应当拥有并发安全。因为它们很自然地会在不同Go程中被使用。

包内的类型实例默认情况下不考虑并发安全。因为是一个个实例，并发安全交由外部自行保证。

2.
包级函数非并发安全需要特别说明（注释中）。

对于某些拥有“大数量”的实例，通常实现为一个通过管道获取数据的“微服务”。
在内部，如果实例拥有不变性，则无需锁。否则通常需要互斥保护。
返回的管道可由多个Go程并发使用（读取）。
