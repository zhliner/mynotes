前言
----
可以免费获编译器  // 获 => 获取

1.3
---
作为为参数传递给某函数时  // 为为 => 为

1.7
---
Go语言允许这样的一个简单的语句结果作为循环的变量声明出现在  // 循环的变量 => 局部的变量 （原文：local variable）

2.1
---
那么它的就只在函数内部有效  // 它的就 => 它就
当名字有几个单词组成的时优先使用大小写分隔  // 组成的时 => 组成时 or 组成的时候

2.2
---
程序对应一个或多个以.go为文件后缀名的源文件中。  // 文件中 => 文件 （注：整体语义逻辑）

分别是使用在局部定义的两个常量作为调用函数的参数  // 是使用 => 使用

2.3
---
用于需要显式指定变量类型地方  // 类型地方 => 类型的地方

将右边各个的表达式值赋值给左边  // 各个的表达式值 => 各个表达式的值

第二个简短变量声明语句改用普通的多重赋值语言  // 语言 => 语句

就是是  // 就是

第一个是的命令行标志参数的名字  // 是的命令行 => 是命令行

将于创建一个对应字符串类型的标志参数变量  // 将于创建 => 将创建

返回值对应对应一个字符串类型的  // 对应对应 => 对应

另一个创建变量的方法是调用用内建的  // 调用用 => 调用

变量的生命周期指的是在程序运行期间变量有效存在的时间间隔  // 时间间隔 => 时间段

局部变量的声明周期则是动态的  // 声明周期 => 生命周期

函数的有右小括弧也可以另起一行缩进  // 有右小括弧 => 右小括弧

2.4
---
对于值产生一个结果的情形  // 值产生 => 只产生

2.5
---
类型的一个叫名叫  // 叫名叫 => 名叫

2.7
---
任何在在函数外部  // 在在 => 在

然后每个是每个分支的词法域  // 每个是每个 => 是每个

变量f的作用域只有在if语句内  // 只有在 => 只在

3.1
---
它们按照先级递减的顺序的排列
// 按照先级 => 按照优先级
// 顺序的 => 顺序

而且最左边的bit为是1的话  // bit为是 => bit位是

将一个值从一种类型转化位另一种类型  // 转化位 => 转化为

会遇到类似下面的代码通用的错误  // 通用的错误 => 通常的错误

3.2
---
对应整数整数坐标  // 整数整数 => 整数

通过平移转换位网格单元的中心  // 转换位 => 转换

3.3
---
分形图像图像输出到标准输出  // 图像图像 => 图像

运行客户端用过HTTP参数参数指定
// 用过 => 通过
// 参数参数 => 参数

3.5
---
不变性意味如果两个字符串共享相同  // 意味如果 => 意味着如果

将一系列字节序列包含在双引号即可  // 双引号即可 => 双引号内即可

因为大数据计算机可读的文本是  // 大数据 => 大多数

用于表示总共有多少编码个字节
// 用于表示编码总共有多少个字节

比如区分字母和数组  // 数组 => 数字

它包混合了中西两种字符  // 包混合 => 混合

将会发送什么呢  // 发送 => 发生

函数灵感于  // 灵感于 => 灵感源于

简化个版本使用了  // 简化个 => 简化

将一个表示整值的字符串  // 整值 => 整数值

则不需要插入逗分隔符  // 逗分隔符 => 逗号分隔符

函数将在最后三个字符前位置将字符串切割为两个两个子串并插入逗号分隔符
// 字符前位置 => 字符前
// 两个两个 => 两个

调用自身来出前面的子串  // 来出 => 来得出

一个字符串是包含的只读字节数组
// 一个字符串是包含只读字节的数组

我们将看看如何将它用作一个  // 看看 => 看到

字符串和数字的转换  // 数字 => 数值

判断两个字符串是否是是相互打乱的  // 是否是是 => 是否是

特别是在需要包含附加额外信息的时候  // 包含附加额外 => 包含有附加额外

3.6
---
常量可以有任意有一个确定的基础类型  // 有任意有 => 有任意

可以像下面常量表达式依然有效  // 可以像下面常量 => 像下面的常量

4.1
---
可以增长和收缩动态序列  // 收缩 => 收缩的

4.2
---
或者的两种风格的混合语法初始化  // 或者的 => 或者用

我们可以可以达到  // 可以可以 => 可以

4.3
---
你可以需要区分一个已经存在的  // 可以需要 => 可能需要

跟踪那些出现过字符的次数  // 出现过字符 => 出现过的字符

4.4
---
经典案例处理公司的员工信息  // 案例 => 案例是

该限制同样适应于数组  // 适应于 => 适用于

因为，提供了成员的名字 // 因为，=> 因为

所有成员出现的顺序并不重要  // 所有 => 所以

它是下面的语句是等价的  // 它是 => 它和

4.5
---
写成以系列的name:value对形式  // 以系列 => 一系列

在两种之间相互转换  // 两种之间 => 两者之间

这是因为构体成员Tag所导致的  // 构体 => 结构体

一个构体成员Tag  // 构体 => 结构体

因为值中含义双引号字符  // 含义 => 含有

表示当Go语言结构体成员为空或零值时不生成JSON对象  // JSON对象 => 该JSON对象

slice将被只含有Title信息值填充  // 信息值 => 信息的值

4.6
---
这写功能是由  // 这写 => 这些

这些都可能让模板输出错误的输出  // 模板输出？

5.1
---
被认为有相同的类型和标识符  // 类型和 => 类型或

5.2
---
与相反  // 与此相反

5.3
---
返回多参数的函数作为该函数的参数  // 函数作为 => 函数调用作为

如果一个函数将所有的返回值都显示的变量名  // 显示的变量名 => 显式的命名

5.4
---
panic是来自被调函数的信号  // 被调 => 被调用

表示发生了某个已知的bug  // 已知的bug ？ 未知的bug

即时是简单的读写  // 即时是 => 即使是

Go使用控制流机制（如if和return）处理异常  // 处理异常 ？ 处理错误

调用者有应该选择何时的方式处理错误
// 有应该 => 应该
// 何时的 => 合适的

以OS包为例，OS包确保文件操作  // OS包 => os包 （注：2处）

设置log的前缀信息屏蔽时间信息
// ？
// 添加log的前缀信息替代时间信息
// 注：
// log.std默认并无前缀，前端时间是由log.SetFlags决定。
// 原译文易误解为“时间信息为前缀”

log包提供函数  // 提供 => 提供的

或者标准错误流输出错误信息  // 或者 => 或者在

你应该在清晰的记录下你的意图  // 在清晰 => 清晰

5.6
---
它的值被成为匿名函数  // 被成为 => 被称为

每次调用时匿名函数时  // 调用时 => 调用

考虑这个样一个问题  // 这个样 => 这样

5.7
---
参数数量可变的函数称为为可变参数函数  // 称为为 => 称为

首先接收一个的必备参数  // 的必备 => 必备的

5.8
---
defer trace("bigSlowOperation")() // don't forget the ...
// 注：下行内容不应单独一行

defer f.Close() // NOTE: risky; could run out of file
// 注：下行内容应上移连接

5.9
---
之前被延迟执行的的3个  // 的的3个 => 的3个

6.2
---
你需要考虑两方面的内部  // 内部 => 因素

熟悉C或者C艹的人这里应该很快能明白  // C艹 => C++ （注：唉……）

Nil也是一个合法的接收器类型
// Nil => nil
// 接收器类型 => 接收器

这个定义向外部暴露了一个map的类型的变量  // map的类型的变量 => map的命名类型 （注：无原文，存疑？）

编译器无法判断其准备类型  // 准备类型 => 准确类型

6.4
---
选择器会返回一个方法"值"->一个将方法(Point.Distance)
// 选择器会返回一个方法“值”——一个将方法（Point.Distance）

// 看起来本书中函数和方法的区别是指有没有接收器，而不像其他语言那样是指有没有返回值。
添加：
// 方法表达式提供了一种将方法转换为普通函数的机制，使得接收者可以被任意指定（当然局限于相同类型）。
// 同时，如果方法的函数签名相同，则方法本身也可转化为普通的函数赋值，实现不同方法的相同调用，如下例。

6.5
---
我们还会程序用到这个64位字的例子  // 还会程序 => 还会有程序

这样相当远我们还是调用  // 相当远 => 相当于

6.6
---
他也可以允许其它包中可以直接读取并  // 他也可以 => 但它也可以

换句话说，相对  // 相对 => 相对于

7.1
---
实现一个针对对单词和行数的计数器  // 针对对 => 针对

7.2
---
io.Writer类型是用的最广泛的接口之一  // 是用的 => 是用得

或者甚至使用种混合的风格  // 使用种 => 使用一种

7.3
---
只要这个类型实现这个接口  // 实现 => 实现了

就像信封封装和隐藏信件起来一样  // 隐藏信件起来 => 因此起信件

和少一些方法的接口类型,例如io.Reader，进行对比；
// 和少一些方法的接口类型，例如io.Reader进行对比：

从本书最早的的例子中  // 的的 => 的

依赖于判断的两个类型的方法  // 判断的两个 => 判断两个

所以没有必要定义一个  // 定义 => 去定义

尤其当一个或多个接口方法像Write方法那样隐式的给接收者带来变化的时候
// 尤其当一个或多个接口方法如Write那样会隐式改变接收者的时候

和表示他们之间的共同特定  // 特定 => 特点

7.5
---
*os.Stdout  // => *os.File

和它之前定义时相同的状态图  // 状态图 => 状态

接口值可以使用来进行比较  // ＝＝和！＝ => ==和!=

动态类型的＝＝操作相等  // ＝＝ => ==

7.6
---
忽略大些或者含有特殊的字符  // 忽略大些 => 忽略大小写

下面的变量tracks包好了一个播放列表  // 包好了 => 包含了

那样定义一个新的带有必须Len，Less和Swap方法的切片类型  // 带有必须 => 带有

func (x customSort) Len() int
// func (x customSort) Len() int           { return len(x.t) }

7.7
---
为了销售它的数据库将它物品的价格映射成美元
// 为了销售，它将数据库内物品的价格映射成美元

就像Ruby语言有Rails和python有Django
// 就像Ruby语言有的Rails和python有的Django

以至于这些框架都是不必要的  // 是不必要的 => 不是必要的 （注：？）

带来额外的复杂度会使长期的维护更加困难  // 带来额外的 => 带来的额外

使用ServeMux最为主要的handler
// 使用ServeMux为主handler

一个程序，它有两个
// 一个程序：它有两个

构建另外一个ServeMux并且在调用一次  // 在调用 => 再调用

必须全部都显示的注册到  // 显示的 => 显式地

其它请求也可以访问的变量时一定要使用预防措施比如锁机制
// 其它请求也可以访问的变量时，一定要使用预防措施，比如锁机制

我们后面的两章中讲到并发相关的知识  // 中讲到 => 将讲到

让客服端可以创建  // 客服端 => 客户端

7.9
---
每个表示式去定义一个Eval方法  // 表示式 => 表达式

像这个一样成功的测试用例  // 像这个一样 => 像这样一个

绘制了一个在编译器才确定的函数  // 编译器 => 编译期

7.10
----
如果相反断言的类型T是一个接口类型  // 相反 => 相反地

经常地我们对一个接口值的动态类型是  // 经常地 => 通常，

在失败的时候发生panic  // =>，

但是代替地返回一个额外的第二个结果，这个结果是一个标识成功的布尔值
但是替代地返回一个额外的第二个结果，这个结果是一个标识成功与否的布尔值：

第二个结果常规地赋值给一个命名为  // 常规地 => 通常

原来的变量名重用而不是声明一个新的本地变量  // 本地变量 => 本地变量名 （注：区别很大，实际上是声明了一个同名的新的本地变量）
测试代码：
	func main() {
		var w io.Writer = os.Stdout

		f, ok := w.(*os.File)
		fmt.Printf("%v, %T %T\n", ok, f, w)

		if w, ok := w.(*bytes.Buffer); !ok {
			fmt.Printf("%T\n", w)
		}
		fmt.Printf("%T\n", w)
	}
	// output:
	// true, *os.File *os.File
	// *bytes.Buffer
	// *os.File



7.11
----
具体的类型比字符串可以提供更多  // 比字符串可以 => 可以比字符串

7.12
----
就方法必须和  // 就方法 => 方法就

满足这个两个接口类型中的一个  // 这个两个 => 这两个

7.13
----
类型开关  // 开关 => 分支

对一连串值做相等测试  // 做相等 => 做类型相等 （注：？）

一个类型开关隐式的创建了一个语言块  // 语言块？（注：逻辑上讲应为“词法块”）
隐式的创建一个单独的语言块  // 语言块

7.14
----
这个case集合中每一个case中有不同的逻辑  // case中 => case

每次main函数中的循环遇到
// main函数中的循环每次遇到

每一个元素节点有一个字节点的切片  // 字节点 => 子节点

7.15
----
完成了对methods和接口的学习过程  // methods => 方法

不是任何事物都需要被当做成一个对象  // 当做成 => 当成

相反的是普遍的函数调用  // 普遍的 => 普通的


8.4
---
都需要在不使用的使用调用对应的  // 不使用的使用 => 不使用的时候

如果未能分配足够的缓冲将导致程序死锁
// 如果 => 而如果
// 缓冲 => 缓存

传递到它下一个厨师在生产线  // 厨师在 => 厨师的

8.5
---
最后一个结束并不一定是最后一个开始
// 最后一个结束的并不一定是最后一个开始的

8.6
---
我们会让这个这个爬虫并行化  // 这个这个 => 这个

总是会有一个些限制因素  // 一个些 => 一些个

计算器n
// 计数器n

在没有被转义的情况下是无法在函数外部访问的  // 转义 => 转出

8.7
---
从标准输入中调入一个单独的  // 调入 => 读入

和最后的default选择支  // 选择支 => 选择分支

语句会会一直等待到两个事件中的一个到达
// 会会 => 会
// 等待到 => 等待直到

8.8
---
并且会对每一个文件也递归调用  // ？代码逻辑

8.9
---
不要向channel发送值  // 不要向 => 不用向

8.10
----
来接收向客户端发出消息channel中发送的广播消息
// 来接收向客户端channel发送的广播消息

客户端的读取方循环  // 读取方 => 读取

会在下一章中更多地解决约束  // 更多的解决 => 更多的探讨

而不是等待这个客户端一直到其准备好写  // 准备好写 => 准备好可写

9.1
---
当我们能够没有办法自信地确认  // 能够没有办法 => 没有办法

icons就再也不会修改的  // 就再也 => 就是再也

避免从多个goroutine访问变量  // 访问变量 => 访问相同变量

使用一个channel来发送给指定的goroutine请求来查询更新变量
// 使用一个channel来给指定的goroutine发送请求来查询和更新变量

叫做这个变量的监控(monitor)goroutine
// 叫做这个变量的monitor（监控）goroutine


9.4
---
一种尝试是去将其运行理解为  // 是去将 => 是将

9.5
---
如果在程序启动的时候就去做这类的初始化的话会增加程序的启动时间并且因为执行的时候可能也并不需要这些变量所以实际上有一些浪费
// 如果在程序启动的时候就去做这类的初始化的话，会增加程序的启动时间，并且因为执行的时候可能也并不需要这些变量所以实际上有一些浪费

让我们在本章早一些时候看到的icons变量
// 让我们看看在本章早些时候看到的icons变量

我们希望现在你从现在开始能够构建自己对并发的直觉，也就是说对并发的直觉总是不能被信任的
// 我们希望你从现在开始能够构建起自己对并发的直觉——就是对并发的直觉总是不能被信任的


9.6
---
请保证你的测试并发地覆盖到了你到包  // 你到包 => 你的包

9.7
---
所有的例子都会遵循这些上面的这些方面
// 这些上面 => 上面
// 方面 => 设定

9.8
---
并保存内存中它的寄存器内容
// 并将它的寄存器内容保存到内存

然后恢复执行该线程的现场并开始执行线程
// 然后恢复该线程的现场并开始执行线程

以一个普通值的形式被被很容易地获取到  // 被被 => 被

11.0
----
这些通常都是精心设计的执行某些特定的功能或者是通过随机性的输入待验证边界的处理
// 这些通常都是精心设计的执行某些特定的功能，或者是通过随机性的输入待验证边界的处理

11.2
----
是一个在外部测试包内的白盒测试  // 是一个 => 一个

只有在测试中出现重复模式是才采用抽象  // 模式是 => 模式时

人很容易想预先写下一系列  // 人很 => 人们很

11.5
----
语言的分析据工具  // 分析据 => 分析数据

12.0
----
一个是fmt包提供的字符串格式功能  // 格式功能 => 格式化功能

12.1
----
设计该函数的时候还这些类型  // 还这些 => 这些
